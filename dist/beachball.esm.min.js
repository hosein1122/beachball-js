class t{constructor(t=0,s=0,e=0){this.val=t,this.strike=s,this.dip=e}}class s{constructor(t=0,s=0,e=0){this.strike=t,this.dip=s,this.rake=e}}class e{constructor(...t){if(2===t.length){const s=t[0];if(this.expo=t[1],Array.isArray(s)&&6===s.length)this.mt=[[s[0],s[3],s[4]],[s[3],s[1],s[5]],[s[4],s[5],s[2]]];else{if(!Array.isArray(s)||3!==s.length||!Array.isArray(s[0]))throw new TypeError("Invalid parameter size for MomentTensor.");if(3!==s.length||3!==s[0].length)throw new TypeError("Full matrix must be 3Ã—3.");this.mt=s}}else{if(7!==t.length)throw new TypeError("Wrong number of parameters for MomentTensor.");{const[s,e,a,h,i,r,n]=t;this.mt=[[s,h,i],[h,e,r],[i,r,a]],this.expo=n}}}get mtNormalized(){const t=this.mtFrobeniusNorm();return this.mt.map(s=>s.map(s=>s/t))}mtFrobeniusNorm(){return Math.sqrt(this.mt.reduce((t,s)=>t+s.reduce((t,s)=>t+s*s,0),0))}get normalized(){return new e(this.mtNormalized,this.expo)}get xx(){return this.mt[0][0]}get xy(){return this.mt[0][1]}get xz(){return this.mt[0][2]}get yy(){return this.mt[1][1]}get yz(){return this.mt[1][2]}get zz(){return this.mt[2][2]}}function a(t,s="asc"){function e(t,e){const a="asc"===s?[2,1,0]:[0,1,2];return{values:a.map(s=>t[s]),vectors:a.map(t=>function(t){const s=t.reduce((t,s,e,a)=>Math.abs(s)>Math.abs(a[t])?e:t,0);return t[s]<0?t.map(t=>-t):t}(e[t]))}}let a=0;for(let s=0;s<3;++s)for(let e=s;e<3;++e)a=Math.max(a,Math.abs(t[s][e]));if(0===a)return e([0,0,0],[[1,0,0],[0,1,0],[0,0,1]]);const h=t.map(t=>t.map(t=>t/a)),[i,r,n]=[h[0][0],h[0][1],h[0][2]],[o,l,c]=[h[1][1],h[1][2],h[2][2]],M=r*r+n*n+l*l;if(0===M)return e([i,o,c].map(t=>t*a),[[1,0,0],[0,1,0],[0,0,1]]);const p=(i+o+c)/3,u=(i-p)**2+(o-p)**2+(c-p)**2+2*M,f=Math.sqrt(u/6),m=(i-p)/f,d=r/f,g=n/f,y=(o-p)/f,b=l/f,w=(c-p)/f,P=(m*y*w+2*d*g*b-m*b*b-y*g*g-w*d*d)/2,v=Math.max(-1,Math.min(1,P)),A=Math.acos(v)/3,x=p+2*f*Math.cos(A),I=p+2*f*Math.cos(A+2*Math.PI/3),k=[x,3*p-x-I,I].map(t=>t*a),_=k.map(t=>function(t){const s=[[h[0][0]-t,h[0][1],h[0][2]],[h[1][0],h[1][1]-t,h[1][2]],[h[2][0],h[2][1],h[2][2]-t]];let e=[s[0][1]*s[1][2]-s[0][2]*s[1][1],s[0][2]*s[1][0]-s[0][0]*s[1][2],s[0][0]*s[1][1]-s[0][1]*s[1][0]],a=Math.hypot(...e);return 0===a&&(e=[s[0][1]*s[2][2]-s[0][2]*s[2][1],s[0][2]*s[2][0]-s[0][0]*s[2][2],s[0][0]*s[2][1]-s[0][1]*s[2][0]],a=Math.hypot(...e),0===a&&(e=[0,0,0],a=1)),e.map(t=>t/a)}(t/a));return e(k,_)}function h(t,s,e,a){try{if(void 0===e.length)throw new TypeError;if(2!==e.length)throw new Error("res must contain exactly two elements")}catch(t){if(!(t instanceof TypeError))throw t;e=[e,e]}return{vertices:t.map((t,h)=>[t*e[0]+a[0],s[h]*e[1]+a[1]]),res:e,center:a}}const i=Math.PI/180,r=180/Math.PI,n=1e-5;function o(t,s){const e=Array.isArray(t),a=Array.isArray(s),h=(t,s)=>[s*Math.cos(t),s*Math.sin(t)];if(!e&&!a)return h(t,s);const i=e?t:Array(s.length).fill(t),r=a?s:Array(t.length).fill(s);if(i.length!==r.length)throw new Error("pol2cart: th and r must have the same length when arrays");const n=[],o=[];for(let t=0;t<i.length;t+=1){const[s,e]=h(i[t],r[t]);n.push(s),o.push(e)}return[n,o]}function l(t,s=200,e=[0,0],a=200){try{if(void 0===a.length)throw new TypeError;if(2!==a.length)throw new Error("width must contain exactly two elements")}catch(t){if(!(t instanceof TypeError))throw t;a=[a,a]}let r=t.strike,n=t.dip,l=t.rake,c=0;l>180&&(l-=180,c=1),l<0&&(l+=180,c=1);let[M,p,u]=function(t,s,e){const a=180/Math.PI,h=(t+90)/a,i=s/a,r=e/a,n=-Math.cos(r)*Math.cos(h)-Math.sin(r)*Math.sin(h)*Math.cos(i),o=Math.cos(r)*Math.sin(h)-Math.sin(r)*Math.cos(h)*Math.cos(i),l=Math.sin(r)*Math.sin(i),[c,M]=function(t,s,e){const a=180/Math.PI;e<0&&(0!=t&&(t=-t),0!=s&&(s=-s),e=-e);let h=Math.atan2(s,t)*a;for(h-=90;h>=360;)h-=360;for(;h<0;)h+=360;const i=Math.sqrt(t*t+s*s);return[h,Math.atan2(i,e)*a]}(o,n,l),p=-o,u=n;let f=(p*(Math.sin(h)*Math.sin(i))+u*(Math.cos(h)*Math.sin(i)))/Math.sqrt(p*p+u*u);Math.abs(f)>1&&Math.abs(f)<1.0000000000000222&&(f=Math.sign(f));const m=Math.acos(f);return[c,M,l>0?m*a:-m*a]}(r,n,l);const f=s/2;n>=90&&(n=89.9999),p>=90&&(p=89.9999);const m=[];for(let t=0;t<Math.PI;t+=.01)m.push(t);const d=90-n,g=90-p,y=m.map(t=>{const s=d*d,e=Math.sin(t)**2+Math.cos(t)**2*(d*d)/8100;return Math.sqrt(s/e)}),b=m.map(t=>{const s=g*g,e=Math.sin(t)**2+Math.cos(t)**2*(g*g)/8100;return Math.sqrt(s/e)}),w=[];for(const t of[(c+1)%2,c]){let n=1;const[l,c]=o(m.map(t=>t+r*i),y);let p,u,d,g,v,A;if(1===t)r-180>M&&(n=-1),p=P(r-180,M,n),[d,g]=o(p.map(t=>t*i),Array(p.length).fill(90)),[v,A]=o(m.map(t=>t+M*i),b),u=P(M+180,r,-n);else{let t=r-180,s=M-180;s>t&&(n=-1),p=P(t,s,-n),[d,g]=o(p.map(t=>t*i),Array(p.length).fill(90)),[v,A]=o(m.map(t=>t+M*i),b),v.reverse(),A.reverse(),u=P(M,r,n)}const[x,I]=o(u.map(t=>t*i),Array(u.length).fill(90)),k=[...l,...d,...v,...x],_=[...c,...g,...A,...I],C=k.map(t=>t*f/90),T=_.map(t=>t*f/90),E=a.map(t=>t/s);w.push(h(T,C,E,e))}function P(t,s,e=1){const a=[];if(e>0)for(let h=t;h<s;h+=e)a.push(h);else for(let h=t;h>s;h+=e)a.push(h);return a}return[["b","w"],w]}class c extends HTMLElement{static get observedAttributes(){return["focal-mechanism","width","height","tension-color","bg-color","edge-color","line-width","size"]}constructor(){super();const t=this.attachShadow({mode:"open"}),s=document.createElement("style");s.textContent="\n      :host {\n        display: inline-block;\n        position: relative;\n        width: var(--bb-width, 200px);\n        height: var(--bb-height, 200px);\n      }\n      canvas {\n        width: 100%;\n        height: 100%;\n        display: block;\n      }\n    ",t.appendChild(s),this.canvas=document.createElement("canvas"),t.appendChild(this.canvas)}attributeChangedCallback(t,s,e){switch(t){case"focal-mechanism":try{this.focalMechanism=JSON.parse(e)}catch(t){}break;case"width":{const t=parseInt(e)||200;this.canvas.width=t,this.hasAttribute("height")||(this.canvas.height=t,this.style.setProperty("--bb-height",`${t}px`)),this.style.setProperty("--bb-width",`${t}px`);break}case"height":{const t=parseInt(e);this.canvas.height=t,this.style.setProperty("--bb-height",`${t}px`);break}case"tension-color":this.tensionColor=e;break;case"bg-color":this.backgroundColor=e;break;case"edge-color":this.edgeColor=e;break;case"line-width":this.lineWidth=parseFloat(e);break;case"size":this.size=Math.max(100,parseInt(e))}this._draw()}set focalMechanism(t){let h=null,i=null;if(Array.isArray(t)&&6===t.length)h=new e(...t,0),i=function(t){const{values:e,vectors:h}=a(t.mt,"asc"),i=[[h[0][0],h[1][0],h[2][0]],[h[0][1],h[1][1],h[2][1]],[h[0][2],h[1][2],h[2][2]]],r=[e[1],e[2],e[0]];let n=[[i[1][1],-i[1][2],-i[1][0]],[i[2][1],-i[2][2],-i[2][0]],[-i[0][1],i[0][2],i[0][0]]];for(let t=0;t<3;t++)n[0][t]<0&&(n[0][t]*=-1,n[1][t]*=-1,n[2][t]*=-1);const o=r.indexOf(Math.max(...r)),l=r.indexOf(Math.min(...r)),c=[(n[0][o]+n[0][l])/Math.SQRT2,(n[1][o]+n[1][l])/Math.SQRT2,(n[2][o]+n[2][l])/Math.SQRT2],M=[(n[0][o]-n[0][l])/Math.SQRT2,(n[1][o]-n[1][l])/Math.SQRT2,(n[2][o]-n[2][l])/Math.SQRT2],p=t=>Math.hypot(...t),u=c.map(t=>t/p(c)),f=0===p(M)?[NaN,NaN,NaN]:M.map(t=>t/p(M)),m=f[2]>0,d=m?f.map(t=>-t):f,g=m?u.map(t=>-t):u,[y,b,w]=function(t,s){let[e,a,h]=t;const[i,r,n]=s,o=1e-6,l=57.2957795;let c,M,p;if(Math.abs(h)<o){c=90;let t=Math.abs(e);t>1&&(t=1),M=Math.asin(t)*l;const s=-e;s>=0&&a<0&&(M=180-M),s<0&&a<=0&&(M=180+M),s<0&&a>0&&(M=360-M),p=Math.asin(Math.abs(n))*l;const h=-n;let u;u=Math.abs(e)<o?i/a:-r/e,h>=0&&u<0&&(p=180-p),h<0&&u<=0&&(p-=180),h<0&&u>0&&(p=-p)}else{-h>1&&(h=-1);const t=Math.acos(-h);c=t*l;const s=Math.sin(t);if(0===s)return;const o=-e/s,u=a/s;let f=Math.abs(o);f>1&&(f=1),M=Math.asin(f)*l,o>=0&&u<0&&(M=180-M),o<0&&u<=0&&(M=180+M),o<0&&u>0&&(M=360-M);let m,d=-n/s;f=Math.abs(d),f>1&&(f=1),p=Math.asin(f)*l,0===o?m=i/u:(m=-s*(a*h*n/(s*s)+r)/e,0===u&&(m=r/o)),d>=0&&m<0&&(p=180-p),d<0&&m<=0&&(p-=180),d<0&&m>0&&(p=-p)}return[M,c,p]}(d,g);return new s(360-y,b,180-w)}(h);else{if(!Array.isArray(t)||3!==t.length)throw new TypeError("Wrong input value for 'fm'.");i=new s(...t)}this._mt=h,this._np1=i,this._draw()}get focalMechanism(){return this._mt?this._mt:this._np1}connectedCallback(){const t=this.hasAttribute("width")?+this.getAttribute("width"):200;this.canvas.width=t,this.style.setProperty("--bb-width",`${t}px`);const s=this.hasAttribute("height")?+this.getAttribute("height"):t;this.canvas.height=s,this.style.setProperty("--bb-height",`${s}px`),this.tensionColor=this.getAttribute("tension-color")||"#87CEEB",this.backgroundColor=this.getAttribute("bg-color")||"#FFFFFF",this.edgeColor=this.getAttribute("edge-color")||"#000000",this.lineWidth=+this.getAttribute("line-width")||2,this.size=Math.max(100,+this.getAttribute("size")||100),this._draw()}_drawPatches(t,s,e,a=!0,h=!1){t.save(),t.translate(0,t.canvas.height),t.scale(1,-1),t.lineWidth=this.lineWidth,t.strokeStyle=this.edgeColor,e.forEach((e,i)=>{t.fillStyle=s[i],t.beginPath(),"ellipse"===e.type?t.ellipse(e.xy[0],e.xy[1],e.width/2,e.height/2,0,0,2*Math.PI):e.vertices.forEach(([s,e],a)=>a?t.lineTo(s,e):t.moveTo(s,e)),t.closePath(),a&&t.fill(),h&&t.stroke()}),t.restore()}_axisOnBeachball(t,s,e=90,a=20){const h=t*Math.PI/180,i=(90-s)*e/90+a,r=Math.cos(h)*i;return[Math.sin(h)*i,r]}_getFillColors(t,s){return s.map((s,e)=>"b"===t[e]?this.tensionColor:this.backgroundColor)}_draw(){if(!this._np1)return;const s=this.canvas.getContext("2d");s.fillStyle=this.backgroundColor,s.fillRect(0,0,this.canvas.width,this.canvas.height),s.lineWidth=this.lineWidth,s.strokeStyle=this.edgeColor;const e=this.canvas.width/2,o=this.canvas.height/2,c=[e,o],M=[this.canvas.width-2*s.lineWidth,this.canvas.height-2*s.lineWidth];let p,u;if(this._mt){const[f,m,d]=function(s){const{values:e,vectors:h}=a(s.mt,"asc"),i=[[h[0][0],h[1][0],h[2][0]],[h[0][1],h[1][1],h[2][1]],[h[0][2],h[1][2],h[2][2]]];let n=[Math.asin(-i[0][0]),Math.asin(-i[0][1]),Math.asin(-i[0][2])],o=[Math.atan2(i[2][0],-i[1][0]),Math.atan2(i[2][1],-i[1][1]),Math.atan2(i[2][2],-i[1][2])];for(let t=0;t<3;t++)n[t]<=0&&(n[t]=-n[t],o[t]+=Math.PI),o[t]<0&&(o[t]+=2*Math.PI),o[t]>2*Math.PI&&(o[t]-=2*Math.PI);n=n.map(t=>t*r),o=o.map(t=>t*r);const l=[0,1,2].sort((t,s)=>e[t]-e[s]),[c,M,p]=l;return[new t(e[p],o[p],n[p]),new t(e[M],o[M],n[M]),new t(e[c],o[c],n[c])]}(this._mt.normalized),g=Math.min(this.canvas.width,this.canvas.height)/2-this.lineWidth,y=0,[b,w]=this._axisOnBeachball(f.strike,f.dip,g,y),[P,v]=this._axisOnBeachball(d.strike,d.dip,g,y);if(Math.abs(m.val)<n&&Math.abs(f.val+d.val)<n){[p,u]=l(this._np1,this.size,c,M);const t=this._getFillColors(p,u);this._drawPatches(s,t,u,!0,!0)}else{[p,u]=function(t,s,e,a=200,r=!0,o=0,l=0,c=[0,0],M=200){try{if(!Array.isArray(M)||2!==M.length)throw new TypeError}catch(t){M=[M,M]}const p=[],u=[],f=M.map(t=>t/a);let m=0,d=1,g=0,y=0,b=0;const w=Array.from({length:3},()=>new Array(2).fill(0)),P=new Array(400).fill(0),v=new Array(400).fill(0),A=new Array(400).fill(0),x=new Array(400).fill(0),I=new Array(400).fill(0),k=new Array(400).fill(0),_=new Array(800).fill(0),C=new Array(800).fill(0),T=new Array(400).fill(0),E=new Array(400).fill(0),z=[t.strike,s.strike,e.strike],F=[t.dip,s.dip,e.dip],S=[t.val,s.val,e.val];let N=(S[0]+S[1]+S[2])/3;for(let t=0;t<3;t++)S[t]=S[t]-N;const W=.5*a;if(Math.abs(S[0]*S[0]+S[1]*S[1]+S[2]*S[2])<n){if(N>0){const t={type:"ellipse",xy:c,width:M[0],height:M[1]};p.push(t),u.push("b")}if(N<0){const t={type:"ellipse",xy:c,width:M[0],height:M[1]};p.push(t),u.push("w")}return[u,p]}let q,R;Math.abs(S[0])>=Math.abs(S[2])?(q=0,R=2):(q=2,R=0),r&&(N=0);const Q=-S[1]/S[q],O=N/S[q];if(O<-1)return p.push({type:"ellipse",xy:c,width:M[0],height:M[1]}),u.push("w"),[u,p];if(O>1-Q)return p.push({type:"ellipse",xy:c,width:M[0],height:M[1]}),u.push("b"),[u,p];const B=Math.sin(F[q]*i),$=Math.cos(F[q]*i),H=Math.sin(F[1]*i),J=Math.cos(F[1]*i),L=Math.sin(F[R]*i),j=Math.cos(F[R]*i),D=Math.sin(z[q]*i),G=Math.cos(z[q]*i),K=Math.sin(z[1]*i),U=Math.cos(z[1]*i),V=Math.sin(z[R]*i),X=Math.cos(z[R]*i);let Y,Z,tt=0;for(let t=0;t<360;t++){const s=t*i,e=(2+2*O)/(3+(1-2*Q)*Math.cos(2*s));if(e>1)m+=1;else{const a=Math.asin(Math.sqrt(e)),h=Math.sin(s),r=Math.cos(s),c=Math.sin(a),M=Math.cos(a),p=M*B+c*h*H+c*r*L,u=M*$*G+c*h*J*U+c*r*j*X,f=M*$*D+c*h*J*K+c*r*j*V;let m,_;Math.abs(u)<n&&Math.abs(f)<n?(m=0,_=0):(_=Math.atan2(f,u),_<0&&(_+=2*Math.PI),m=Math.acos(p/Math.sqrt(p*p+u*u+f*f))),m>Math.PI/2&&(m=Math.PI-m,_+=Math.PI,_>2*Math.PI&&(_-=2*Math.PI));const C=Math.SQRT2*Math.sin(m/2),T=Math.sin(_),E=Math.cos(_);0===t?(w[t][0]=_,P[t]=o+W*C*T,v[t]=l+W*C*E,tt=_):(Math.abs(Math.abs(_-tt)-Math.PI)<10*i&&(w[b][1]=tt,b+=1,w[b][0]=_),Math.abs(Math.abs(_-tt)-2*Math.PI)<2*i&&(tt<_?w[b][0]+=2*Math.PI:w[b][0]-=2*Math.PI),0===b?(P[d]=o+W*C*T,v[d]=l+W*C*E,d+=1):1===b?(A[g]=o+W*C*T,x[g]=l+W*C*E,g+=1):2===b&&(I[y]=o+W*C*T,k[y]=l+W*C*E,y+=1),tt=_)}}w[b][1]=tt,S[1]<0?(Y="b",Z="w"):(Y="w",Z="b");const st={type:"ellipse",xy:c,width:M[0],height:M[1]};if(p.push(st),u.push(Z),0===b)return p.push(h(P.slice(0,360),v.slice(0,360),f,c)),u.push(Y),[u,p];if(1===b){let t;for(t=0;t<d;t++)_[t]=P[t],C[t]=v[t];if(t-=1,w[0][0]-w[0][1]>Math.PI?w[0][0]-=2*Math.PI:w[0][1]-w[0][0]>Math.PI&&(w[0][0]+=2*Math.PI),w[0][0]<w[0][1]){let s=w[0][1]-i;for(;s>w[0][0];){const e=Math.sin(s),a=Math.cos(s);_[t]=o+W*e,C[t]=l+W*a,t+=1,s-=i}}else{let s=w[0][1]+i;for(;s<w[0][0];){const e=Math.sin(s),a=Math.cos(s);_[t]=o+W*e,C[t]=l+W*a,t+=1,s+=i}}for(p.push(h(_.slice(0,t),C.slice(0,t),f,c)),u.push(Y),t=0;t<g;t++)T[t]=A[t],E[t]=x[t];if(t-=1,w[1][0]-w[1][1]>Math.PI?w[1][0]-=2*Math.PI:w[1][1]-w[1][0]>Math.PI&&(w[1][0]+=2*Math.PI),w[1][0]<w[1][1]){let s=w[1][1]-i;for(;s>w[1][0];){const e=Math.sin(s),a=Math.cos(s);T[t]=o+W*e,t+=1,E[t]=l+W*a,s-=i}}else{let s=w[1][1]+i;for(;s<w[1][0];){const e=Math.sin(s),a=Math.cos(s);T[t]=o+W*e,t+=1,E[t]=l+W*a,s+=i}}return p.push(h(T.slice(0,t),E.slice(0,t),f,c)),u.push(Y),[u,p]}if(2===b){let t=0;for(t=0;t<y;t++)_[t]=I[t],C[t]=k[t];t-=1;for(let s=0;s<d;s++)_[t]=P[s],t++,C[t]=v[s];if(m){let s=g-1;for(;s>=0;)_[t]=A[s],t+=1,C[t]=x[s],s-=1;return p.push(h(_.slice(0,t),C.slice(0,t),f,c)),u.push(Y),[u,p]}if(w[2][0]-w[0][1]>Math.PI?w[2][0]-=2*Math.PI:w[0][1]-w[2][0]>Math.PI&&(w[2][0]+=2*Math.PI),w[2][0]<w[0][1]){let s=w[0][1]-i;for(;s>w[2][0];){const e=Math.sin(s),a=Math.cos(s);_[t]=o+W*e,t+=1,C[t]=l+W*a,s-=i}}else{let s=w[0][1]+i;for(;s<w[2][0];){const e=Math.sin(s),a=Math.cos(s);_[t]=o+W*e,t+=1,C[t]=l+W*a,s+=i}}for(p.push(h(_.slice(0,t),C.slice(0,t),f,c)),u.push(Y),t=0;t<g;t++)T[t]=A[t],E[t]=x[t];if(t-=1,w[1][0]-w[1][1]>Math.PI?w[1][0]-=2*Math.PI:w[1][1]-w[1][0]>Math.PI&&(w[1][0]+=2*Math.PI),w[1][0]<w[1][1]){let s=w[1][1]-i;for(;s>w[1][0];){const e=Math.sin(s),a=Math.cos(s);T[t]=o+W*e,t+=1,E[t]=l+W*a,s-=i}}else{let s=w[1][1]+i;for(;s<w[1][0];){const e=Math.sin(s),a=Math.cos(s);T[t]=o+W*e,t+=1,E[t]=l+W*a,s+=i}}return p.push(h(T.slice(0,t),E.slice(0,t),f,c)),u.push(Y),[u,p]}return[u,p]}(f,m,d,this.size,!0,0,0,c,M);const t=this._getFillColors(p,u);this._drawPatches(s,t,u,!0,!1),[p,u]=l(this._np1,this.size,c,M);const e=this._getFillColors(p,u);this._drawPatches(s,e,u,!1,!0)}const A=e+b,x=o-w,I=e+P,k=o-v;s.save(),s.font="bold 18px sans-serif",s.fillStyle="black",s.textAlign="center",s.textBaseline="middle",s.fillText("T",A,x),s.fillText("P",I,k),s.restore()}else{[p,u]=l(this._np1,this.size,c,M);const t=this._getFillColors(p,u);this._drawPatches(s,t,u,!0,!0)}}}customElements.define("beachball-component",c);
